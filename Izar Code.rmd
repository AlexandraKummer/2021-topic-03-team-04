---
title: "Izar Code"
author: "Izar"
date: "1 5 2021"
output: html_document
---


#Loading Data and Packages

```{r}
library(ggplot2)
library(tidyverse)
library(dplyr)
#loading data into Raw_Data dataframe
Raw_Data<- read.table("c://Data_Analysis//RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")
```




#Normalization 
Normalizing Protein data x/ntot   ##results in Norm_Data_df
```{r}
#generates 
T_P_S_df <- data.frame(Total_Protein_Sum)
T_P_S_vec <-c(T_P_S_df[1,],T_P_S_df[4,],T_P_S_df[2,],T_P_S_df[5,],T_P_S_df[3,],T_P_S_df[6,])
T_P_S_vec_div_func <- function(x){
  x/T_P_S_vec
}
Norm_Data_df <- t(data.frame(apply(Raw_Data,1,T_P_S_vec_div_func)))


```

*works----Creating seperate RNAse and Ctrl dfs    ##results in norm_RNAse & norm_Ctrl
```{r}
# Normailized RNAse only
RNAse_select_vec <- c(seq(from =2, to = 150, by = 2))
norm_RNAse <-data.frame(Norm_Data_df[,RNAse_select_vec])

#Normalized Ctrl only
Ctrl_select_vec <- seq(from =1, to = 150, by = 2)
norm_Ctrl <- data.frame(Norm_Data_df[,Ctrl_select_vec])
```

#LOF gefummel ----
*(work in progress)
Trying to apply LOF/lof   ##results in NoOut_norm_RNAse_df & NoOut_norm_Ctrl_df
```{r}
library(DDoutlier)
library(dbscan)
library(psych)

#issues with applying DDoutlier::LOF and dbscan::lof 
' data.frame(apply(data.frame(norm_RNAse[,1],norm_RNAse[,2],norm_RNAse[,3]),1,lof))
Error in FUN(newX[, i], ...) : x needs to be a matrix or a dist object!
 data.frame(apply(data.frame(norm_RNAse[,1],norm_RNAse[,2],norm_RNAse[,3]),1,LOF))
Error in if (k >= n || k < 1) { : missing value where TRUE/FALSE needed'

#creating empty dataframe to store results
NoOut_norm_RNAse_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
'
step 1 seperate the Raw Data into RNAse and Ctrl each with 3680x75 now we have rep 1,2,3 next to each other
step 2 apply(temp_vec,1,LOF_func) to a temp vec consisting of rep n,n+1,n+2
step 3 save into empty df
'
LOF_func <-function(x){ #creating function usable in apply
x <- as.data.frame(x)
  return(lof(x,2))}
n <-1

LOF_func(as.data.frame(c(1,2,10)))




while (n < 75){
    temp_df <- as.matrix(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])
    Output_df <-t(data.frame(apply(temp_df,1,LOF_func)))
    NoOut_norm_RNAse_df <- cbind(NoOut_norm_RNAse_df,Output_df)
    n <- n + 3
}
NoOut_norm_RNAse_df = NoOut_norm_RNAse_df[,-1]
colnames(NoOut_norm_RNAse_df) = c(colnames(norm_RNAse))


#different approach

lof_apply_func <- function(x){
  
  Output_df <- data.frame(matrix(nrow = nrow(x), ncol=0),row.names = row.names(x))
        n <-1
        while (n < 75){
        temp_df <- data.frame(x[,n],x[,n+1],x[,n+2])
          
          for(i in length(row.names(x))){ 
            u <- t(data.frame(temp_df[i,]))
            temp_vec <- as.vector(LOF(u,2))
            temp_Output_df <- rbind(t(data.frame(temp_vec)))
          }
   
        Output_df <- cbind(Output_df,temp_Output_df)
         n <- n + 3
        }
        return(Output_df)
}


'Manual run for error finding'


temp_df <- data.frame(norm_RNAse[,4],norm_RNAse[,5],norm_RNAse[,6
    ])
u <- t(data.frame(temp_df[1,]))
            temp_vec <- c(LOF(u,2)) 
            temp_Output_df <- rbind(t(data.frame(temp_vec)))
            
            
            

# doesnt work either
            
  lof_RNAse <- data.frame(matrix(nrow = 3680, ncol=0),row.names = row.names(norm_RNAse)) #creates df for outputdf to be added to 
        n <-1
        while (n < 75){
          
        temp_df <- data.frame(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])# should be 3680x3 df first 3 colums to be iterated to with n 75
          
        temp_Output_df <- data.frame(matrix(nrow = nrow(0)),ncol(3)) #maybe creating the df before solves something ?
          for(i in 3680){ 
           
            u <- t(data.frame(temp_df[i,])) # should make a 1x3 df  for each row (i) in temp_df and feed into u 
            
            temp_vec <- as.vector(lof(u,2)) #should make length 3
            
            
            temp_Output_df <- rbind(temp_Output_df,t(data.frame(temp_vec))) # temp_output_df should be 3680x3 from r bind the two dfs
          }
   
        lof_RNAse<- cbind(lof_RNAse,temp_Output_df)
         n <- n + 3
        }

        
        
        


```

new start at lof function
```{r}
library(DDoutlier)
library(dbscan)
library(psych)


exp_lof_func <- function(x){
   n <-1
  while (n < 75){
  Output_df <-x
  temp_df <- data.frame(Output_df[,n],Output_df[,n+1],Output_df[,n+2])
    m <- 1
    
   while (m <= nrow(temp_df)) {
    
    temp_df<- LOF(as.data.frame(temp_df[m,]),3)
      m <- m+1
    } 
    
  Output_df[,n:n+2] <-temp_df[,1:3]
  i <-i+1
  }
}

exp_lof_func(norm_RNAse)
```

MONKEY LOF lUkas code
```{r}


RNAse_Data_lof = as.data.frame(matrix(nrow = 3*3680, ncol=25))
rownames(RNAse_Data_lof) = rownames(RNAse_Data_norm)
colnames(RNAse_Data_lof) = colnames(RNAse_Data_norm)

i = 1
while (i <= dim(norm_RNAse)[1]) {
  for (j in 1:dim(RNAse_Data_norm)[2]) {
    x <- as.matrix(c(RNAse_Data_norm[i,j],RNAse_Data_norm[i+1,j+1],RNAse_Data_norm[i+2,j]))
    lof_temp <-lof (x,2)
    RNAse_Data_lof[i,] <- lof_temp
  }
  i <- i + 3
}

```


*not yet necessary bc lof does not work yet
Removing Values based on if Outlier or not ##results in clean_RNAse_df & clean_Ctrl_df'
```{r}
#modifying the LO factor df  to remove any value above  (arbitrary) 1.5, setting all values < 1.5 = 1 and all values >1.5 = 0
data_clean_func <- function(x,z,treshhold){ # x = data to clean # z = LOF output df RNASe or Ctrl #threshhold can be played around with for signifacance of data
  treshhold_clean_func <- function(y){
    if (y >= treshhold){
      y <- NA
    }else{
      y <- 1
    }
  }
  
  binary_removal_df <- data.frame(apply(z,1,treshhold_clean_func))
  
  x*binary_removal_df
  
}


# i realized we might want to set 0 to NA before doing data cleaning think about it later
clean_RNAse_df <- data_clean_func(norm_RNAse,LOF_RNAse,1.5)
clean_RNAse_df[clean_RNAse_df == 0] <- NA
clean_Ctrl_df <- data_clean_func(norm_Ctrl,LOF_Ctrl,1.5)
clean_Ctrl_df[clean_Ctrl_df == 0] <- NA


```
*not yet necessary bc lof does not work yet 
mean of RNAse and Ctrl reps  ## results in clean_mean_RNAse_df & clean_mean_Ctrl_df
```{r}
# creating mean_clean_RNAse_df 3860x25, normalized and cleaned of outlieres
mean_clean_RNAse_df<- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n<-2
while (n < 75){
    temp_df <- data.frame(clean_RNAse_df[,n],clean_RNAse_df[,n+1],clean_RNAse_df[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    mean_clean_RNAse_df<- cbind(mean_clean_RNAse_df,Output_df)
    n <- n + 3
}
colnames(mean_clean_RNAse_df) = c(paste("RNAse","frac",0:25, sep = "_"))
mean_clean_RNAse_df = mean_clean_RNAse_df[,-1]


# creating mean_clean_Ctrl_df 3860x25, normalized and cleaned of outlieres
mean_clean_Ctrl_df<- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n<-1
while (n < 75){
    temp_df <- data.frame(clean_Ctrl_df[,n],clean_Ctrl_df[,n+1],clean_Ctrl_df[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    mean_clean_Ctrl_df<- cbind(mean_clean_Ctrl_df,Output_df)
    n <- n + 3
}
colnames(mean_clean_Ctrl_df) = c(paste("Ctrl","frac",0:25, sep = "_"))
mean_clean_Ctrl_df = mean_clean_Ctrl_df[,-1]
```

#Cleaning Data with mean and median methods
*works----
Creating df with median method ##results in 3680 RNAse_median_df & Ctrl_median_df
Wird angenommen, dass der Median eine gute Methode für n=3 stichproben ist, die robust gegenüber OUtlieren ist."https://wis.kuleuven.be/statdatascience/robust/papers/2002/rousseeuwverboven-robustestimationinverysmallsampl.pdf"
```{r}
RNAse_median_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])
    Output_df <-data.frame(apply(temp_df,1,median))
    RNAse_median_df<- cbind(RNAse_median_df,Output_df)
    n <- n + 3
}
colnames(RNAse_median_df) = c(paste("frac",0:25, sep = "_"))
RNAse_median_df = RNAse_median_df[,-1]



Ctrl_median_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_Ctrl[,n],norm_Ctrl[,n+1],norm_Ctrl[,n+2])
    Output_df <-data.frame(apply(temp_df,1,median))
    Ctrl_median_df<- cbind(Ctrl_median_df,Output_df)
    n <- n + 3
}
colnames(Ctrl_median_df) = c(paste("frac",0:25, sep = "_"))
Ctrl_median_df = Ctrl_median_df[,-1]



```


*works----
now by arithmetic mean ##results in RNAse_mean_df & Ctrl_mean_df
```{r}
RNAse_mean_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    RNAse_mean_df<- cbind(RNAse_mean_df,Output_df)
    n <- n + 3
}
colnames(RNAse_mean_df) = c(paste("frac",0:25, sep = "_"))
RNAse_mean_df = RNAse_mean_df[,-1]



Ctrl_mean_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_Ctrl[,n],norm_Ctrl[,n+1],norm_Ctrl[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    Ctrl_mean_df<- cbind(Ctrl_mean_df,Output_df)
    n <- n + 3
}
colnames(Ctrl_mean_df) = c(paste("frac",0:25, sep = "_"))
Ctrl_mean_df = Ctrl_mean_df[,-1]
```

#Wilcox
*(work in progresss)
Wilcox Comparison tests between RNAse and Ctrl ##results in wilcox_pval_df
```{r}
library(rstatix)
library(stats)
'NONE OF THIS WORKS the output of the wilcox function is a list, we need to access the "statistic value" or the "p.value"'

#creating function to use with our cleaned data for applying wilcox
wilcox_apply_func <-function(x,y){
    output_vec <- vector()
    i <-1
    while(i <= 3680 ){
    #taking rows and making them into vectors usable by the wicoxsonfunc
    u <-unname(as.vector(as.matrix(x[i,]))) 'needs to be an unnamed vector'
    v <-unname(as.vector(as.matrix(y[i,])))
    
    #applyig wilcox to each set of paired control and RNASe vectors
    wilcox_val <- wilcox.test(u,v, exact = FALSE) 'works till here'
                            
    #generating an output vector to store the outputs 
    output_vec <- append(output_vec, wilcox_val$p.value, after = length(output_vec))   #the $p.value should access the list
    i <-i+1
    }
    #saving the output vector as a dataframe with  dim 3680x1 from output_vec
    #wilcox_scores_df <-data.frame(output_vec, row.names = row.names(x))
    #colnames(wilcox_scores_df) <- c("Wilcox_score")
    
}

median_wilcox <- wilcox_apply_func(RNAse_median_df,Ctrl_median_df)

mean_wilcox <- wilcox_apply_func(RNAse_mean_df,Ctrl_mean_df)




'fiddeling with the code'

    output_vec <- vector()
    i <-1
    while(i <= 3680 ){
    #taking rows and making them into vectors usable by the wicoxsonfunc
    u <-unname(as.vector(as.matrix(RNAse_median_df[1,])))
    v <-unname(as.vector(as.matrix(Ctrl_median_df[1,])))
    
    #applyig wilcox to each set of paired control and RNASe vectors
    wilcox_val <- wilcox.test(u,v,exact = FALSE)
                            # alternative = "two.sided",
                            # mu = 0,
                            # paired = TRUE,
                            # exact = FALSE,
                            # correct = FALSE,
                            # conf.int = FALSE,
                            # conf.level = 0.95)
    #generating an output vector to store the outputs 
    append(output_vec, wilcox_val$p.value, after = length(output_vec))   #the $p.value should access the list
    i <-i+1
    }
    #saving the output vector as a dataframe with  dim 3680x1 from output_vec
    wilcox_scores_df <-data.frame(output_vec, row.names = row.names(x))
    colnames(wilcox_scores_df) <- c("Wilcox_score")
    
}


```


*(work in progress)
focusing stat test on changes in fractions 19-25
```{r}


```







# Maxima detection


the global maximum is easely accessible with the max(), the min with min() function
we can acces the location with the which() function, and  we can order the data by size 1,2,3 etc 
local maxima can be defined as =! global maximum and occuring after a decreasing trend on either side of the global maximum
we can generte a test vecotor:
exp_maxima_vec <-c(1,2,3,2,1,6,5,4,2,2,3,4,3,2,5,3,2,1,3,1,4,3,2,2,1)
we expect the maxima to be at positions 3,6,12,15,19,21

the input should be a vector containing the 25 fractions of normalized protein data

*works generating maxima detection testing vector exp_maxima_vec
```{r}
#test vector to look at a complex maxima detection
exp_maxima_vec<-c(1,2,3,2,1,6,5,4,2,2,3,4,3,2,5,3,2,1,3,1,4,3,2,2,1)
barplot(exp_maxima_vec)
```


*works This chunk contains maxima_loc_func a length 25 logicl vec, containing all maxima as True, and a 
Output: maxima_loc_func (x)
testing outputs:    
---exp_maxima_logic_max
---Maxima_location_vector
---exp_maxima_vec

```{r}
'THIS SHIT FINALLY WORKS'

maxima_loc_func <-function(x,threshhold){ # x = Data_vec , threshold = % global max that is recognized as a local max
  
  threshhold_val <- max(x)*threshhold #could define a threshold 
  logic_return <-logical(length = length(x)) #logic vector 25x FALSE
  i <- 1
  while (i <= 25){
# for the first element
    if (i == 1){
      if (x[i] > x[i+1] & x[i] > threshhold_val){ #implementation for the threshhold ?
        logic_return[i] <- TRUE
      }
#for the elemets 2-24
    }else if ( i < length(x)){
        if (x[i] > x[i+1] & x[i] > x[i-1] & x[i] > threshhold_val){ #implementation for the threshhold ?
          logic_return[i] <- TRUE
        }
#for the last element
    }else if ( i == length(x)){
      if (x[i] > x[i-1] & x[i] > threshhold_val){ #implementation for the threshhold ?
        logic_return[i] <- TRUE
      } 
    }
    i  <- i+1
  }
  return(logic_return) #returns the edited logic vector
  
}

exp_maxima_logic_max <- maxima_loc_func(exp_maxima_vec,0.6) #using maxima loc func on the tesing vector

Maxima_location_vector <- which(exp_maxima_logic_max) #returns positions of TRUE

exp_maxima_vec[Maxima_location_vector] #selection of the values of maxima with position vector

```

an alternative to above function not tested yet
```{r}


maxima_loc_func <-function(x){
  
  logic_return <-logical(length = 25) #logic vector 25x FALSE
  
  for (i in x ){

# for the first elemet
    if (match(i,x) == 1){
      if (x[i] > x[match(i,x)+1]){
        logic_return[i] <- TRUE
      }
#for the elemets 2-24
    }else if ( match(i,x) < length(x)){
        if (i > x[match(i,x)+1] & i > x[match(i,x)-1]){
          logic_return[i] <- TRUE
        }
#for the lase element
    }else{
      if (i > x[match(i,x)-1]){
        logic_return[i] <- TRUE
      } 
    }
  }
  return(logic_return)
}



exp_maxima_logic_max <- maxima_loc_func(exp_maxima_vec)
 exp_maxima_logic_max
 
 
 
```



Idea for the "binning" of the maxima as in location only maxima which are "greater" local maxima
eg 12143....    would be 4 not 2 
so we split up the vector into smaller chunks vector[i:i+j] then check if each value is the maximum in that range then move along shifting by 1 so starting at the second entry in the vector and so on if the reading frame pases over the value and leaves it being true then the values is defined as a local maximum per bin size

```{r}
'in words:
define a "reading" frame that checks if each value in the frame is the maximum or not
so we want "m" elements to be selected at position "n"then we want to check if each value is the maximum in the m elements,
when the reading frame moves to start at "n+1" we want the 

idea: what if the function always acceses the same logical vector but always accesses different positions to change the values of the previous run, could even be the same logical vector generated by maxima_loc_func then wed have one output only, if (m == 1|2) then no binsize is applied, if (m >= 3) binfunction  '


# m = binsize , n = element number
# x = a numeric vector, m = binsize, less than 3 not useful
max_bin_func <-function(x,m){
logic_return2 <-logical(length = 25)
n <-1
while (n <= 25){
  logic_return2[which.max(x[n:n+m])+(n-1)] <- TRUE
 n <- n+1
}
return(logic_return2)
}

max_bin_func(exp_maxima_vec,5)
#need function that assings true in a logical( length = m ) to the value which is the maximum
m <-4
result_vector <-character()
while (n <= 25){
  result_vector <-c(result_vector,(which.max(x[n:n+m]))
 n <- n+1
}

#OTHER random idea, what if we check the surrounding values of each maximum to see of its the global maximum in that area, would probs be more efficient so if n is a maximum, we check [n-m:n+m] and see if its = to the global max of the area, issues with two identical maxima....


#which.max(x[n-m:n+m]) + (n-m))
  
    1 1 2 3 4 3 3 2

# just noting that exp_maxima_vec[1:3]<-c(11:13) works for the replacing of values so value replacement works easily



#another idea is to select only the maxima then just work on that vector set a fraction distance which they can be appart and if theyre to far appart dont compare essentially work with both the location vector as well as the maxima value vector'
```


```{r}
'THIS SHIT FINALLY WORKS'




maxima_loc_func <-function(x,threshhold){ # x = Data_vec , threshold = % global max that is recognized as a local max
  
  threshhold_val <- max(x)*threshhold #could define a threshold 
  logic_return <-logical(length = length(x)) #logic vector 25x FALSE
  i <- 1
  while (i <= 25){
# for the first element
    if (i == 1){
      if (x[i] > x[i+1] & x[i] > threshhold_val){ #implementation for the threshhold ?
        logic_return[i] <- TRUE
      }
#for the elemets 2-24
    }else if ( i < length(x)){
        if (x[i] > x[i+1] & x[i] > x[i-1] & x[i] > threshhold_val){ #implementation for the threshhold ?
          logic_return[i] <- TRUE
        }
#for the last element
    }else if ( i == length(x)){
      if (x[i] > x[i-1] & x[i] > threshhold_val){ #implementation for the threshhold ?
        logic_return[i] <- TRUE
      } 
    }
    i  <- i+1
  }
  return(logic_return) #returns the edited logic vector
  
}

maxima_df_func <- function(x,threshhold)
n <-1
while ( n <= dim(x)){
     Output_df maxima_locas.vector(x[i,])
  
  
  
  n+1
}



```


looking at alex cod
```{r}

test_matrix <- matrix(rep(test_vert, 3), byrow=TRUE, nrow=3, ncol=25)
test_df <- data.frame(test_matrix)


max_detec_df <- function(x){
  j=1
  Input_df <- x
  for (j in 1:dim(Input_df)[1]){#j soll die nummer der Zeile annehmen, um auf die Zeile im if statement zuzugreifen
   while (i <= 1:dim(Input_df)[2]){#für eine Zeile weren alle spalten durchgetestet
    if (i == 1){#für die erste spalte, die nur rechts ein vergleichselement hat
      if(Input_df[j,i] > Input_df[j,i+1]){
        Input_df[j,i] <- i #hier soll der leere Vektor als neues element die stelle des maximus bekommen
      }else{
        Input_df[j,i] <- 0#wenn stelle nicht eingesetzt soll der Wert 0 rein, damit der Vektor weiterhin 25 elemente hat
      }
    }
    if (i < dim(Input_df)[2]&& i!=1){
      if(Input_df[j,i]>Input_df[j,i+1] && Input_df[j,i]> Input_df[j,i-1]){
        Input_df[j,i] <- i
      }else {
        Input_df[j,i] <- 0
      }
    }
    if (i == dim(Input_df)[2]){
      if(Input_df[j,i]>Input_df[j,i-1]){
        Input_df[j,i] <- i
      }else{
        Input_df[j,i] <- 0
        }
      }
    i=i+1
    }#nachdem der vektor für eine Zeile fertig ist, soll er in die entsprechenden Zeile der Matrixgefüllt werden
    
  }#j wird jetzt um 1 erhöht, der temp_vec wird mit den locations aus der neuen Zeile überschrieben und dann in die nächste Zeile der Matrix gefüllt
  return(temp_matrix)#am Ende soll eine Martrix entstehen, die für jedes Protein den Vektor enthält
  
}

test_lauf_zwei <- max_detec_df(test_df)#code läuft nicht, ist also kot lul. irgendeine bedingung hat Länge > 1 und das füllen der MAtrix gibt Ersetzung hat die Länge 0
```



