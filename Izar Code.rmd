---
title: "Izar Code"
author: "Izar"
date: "1 5 2021"
output: html_document
---


#Loading Data and Packages

```{r}
library(ggplot2)
library(tidyverse)
library(dplyr)

#loading data into Raw_Data dataframe
Raw_Data<- read.table("c://Data_Analysis//RDeeP_A549_NS.csv", header=TRUE, row.names=1, sep = ";")

#function for ratio of max-min to mean allows setting of univeral limit
min_max_mean_func <- function(x){
  (max(x)-min(x))/mean(x)
}
```
ignore
```{r}

#RNAse Factor df         
#RNAse_frac_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data)) #creating a dataframe to save results too

#n <-2 # for RNAse n = 2 for ctrl n =1 corresponding to position in dataframe
#while (n < 150){ # this will iterate trough all the fractions

 #   temp_df <- data.frame(Raw_Data[,n],Raw_Data[,n+2],Raw_Data[,n+4])  # a temporary df for sotring the 3 reps of each fraction
    
  #  Output_df <-data.frame(apply(temp_df,1,min_max_mean_func))     #the function for comparing (max-min)/mean is applied across the rows apply(...,1,..) for rows 2 for cols
    
   # RNAse_frac_df <- cbind(RNAse_frac_df,Output_df)           #each run through adds a colum to RNAse_frac_df, we end with 26 cols
    
  #  n <- n + 6     # the counter is increased to select the next fraction
#}
#colnames(RNAse_frac_df) = c(paste("frac",0:25, sep = "_"))

#RNAse_frac_df = RNAse_frac_df[,-1] #this code deletes the unnessecary first null colum
```
ignore
```{r}
#
#Control Factor df
#ctrl_frac_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
#n <-1
#while (n < 150){
#    temp_df <- data.frame(Raw_Data[,n],Raw_Data[,n+2],Raw_Data[,n+4]) 
#    Output_df <-data.frame(apply(temp_df,1,min_max_mean_func))
#    ctrl_frac_df <- cbind(ctrl_frac_df,Output_df)
#    n <- n + 6
#}
#colnames(ctrl_frac_df) = c(paste("frac",0:25, sep = "_"))

#ctrl_frac_df = ctrl_frac_df[,-1] #this code deletes the unnessecary first null colum
```


#Normalization and Data cleaning
Normalizing Protein data x/ntot   ##results in Norm_Data_df
```{r}
#generates 
T_P_S_df <- data.frame(Total_Protein_Sum)
T_P_S_vec <-c(T_P_S_df[1,],T_P_S_df[4,],T_P_S_df[2,],T_P_S_df[5,],T_P_S_df[3,],T_P_S_df[6,])
T_P_S_vec_div_func <- function(x){
  x/T_P_S_vec
}
Norm_Data_df <- t(data.frame(apply(Raw_Data,1,T_P_S_vec_div_func)))


```

Creating seperate RNAse and Ctrl dfs    ##results in norm_RNAse & norm_Ctrl
```{r}
# Normailized RNAse only
RNAse_select_vec <- c(seq(from =2, to = 150, by = 2))
norm_RNAse <-data.frame(Norm_Data_df[,RNAse_select_vec])

#Normalized Ctrl only
Ctrl_select_vec <- seq(from =1, to = 150, by = 2)
norm_Ctrl <- data.frame(Norm_Data_df[,Ctrl_select_vec])
```


*(work in progress)
Trying to apply LOF/lof   ##results in NoOut_norm_RNAse_df & NoOut_norm_Ctrl_df
```{r}
library(DDoutlier)
library(dbscan)
library(psych)

#issues with applying DDoutlier::LOF and dbscan::lof 
' data.frame(apply(data.frame(norm_RNAse[,1],norm_RNAse[,2],norm_RNAse[,3]),1,lof))
Error in FUN(newX[, i], ...) : x needs to be a matrix or a dist object!
 data.frame(apply(data.frame(norm_RNAse[,1],norm_RNAse[,2],norm_RNAse[,3]),1,LOF))
Error in if (k >= n || k < 1) { : missing value where TRUE/FALSE needed'

#creating empty dataframe to store results
NoOut_norm_RNAse_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
'
step 1 seperate the Raw Data into RNAse and Ctrl each with 3680x75 now we have rep 1,2,3 next to each other
step 2 apply(temp_vec,1,LOF_func) to a temp vec consisting of rep n,n+1,n+2
step 3 save into empty df
'
LOF_func <-function(x){ #creating function usable in apply
x <- as.data.frame(x)
  return(lof(x,2))}
n <-1

while (n < 75){
    temp_df <- as.matrix(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])
    Output_df <-t(data.frame(apply(temp_df,1,LOF_func)))
    NoOut_norm_RNAse_df <- cbind(NoOut_norm_RNAse_df,Output_df)
    n <- n + 3
}
NoOut_norm_RNAse_df = NoOut_norm_RNAse_df[,-1]
colnames(NoOut_norm_RNAse_df) = c(colnames(norm_RNAse))


#different approach

lof_apply_func <- function(x){
  
  Output_df <- data.frame(matrix(nrow = nrow(x), ncol=0),row.names = row.names(x))
        n <-1
        while (n < 75){
        temp_df <- data.frame(x[,n],x[,n+1],x[,n+2])
          
          for(i in length(row.names(x))){ 
            u <- t(data.frame(temp_df[i,]))
            temp_vec <- as.vector(LOF(u,2))
            temp_Output_df <- rbind(t(data.frame(temp_vec)))
          }
   
        Output_df <- cbind(Output_df,temp_Output_df)
         n <- n + 3
        }
        return(Output_df)
}


'Manual run for error finding'


temp_df <- data.frame(norm_RNAse[,4],norm_RNAse[,5],norm_RNAse[,6
    ])
u <- t(data.frame(temp_df[1,]))
            temp_vec <- c(LOF(u,2)) 
            temp_Output_df <- rbind(t(data.frame(temp_vec)))
            
            
            

# doesnt work either
            
  lof_RNAse <- data.frame(matrix(nrow = 3680, ncol=0,row.names = row.names(norm_RNAse))) #creates df for outputdf to be added to 
        n <-1
        while (n < 75){
          
        temp_df <- data.frame(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])# should be 3680x3 df first 3 colums to be iterated to with n 75
          
        temp_Output_df <- data.frame(matrix(nrow = nrow(0)),ncol(3)) #maybe creating the df before solves something ?
          for(i in 3680){ 
           
            u <- t(data.frame(temp_df[i,])) # should make a 1x3 df  for each row (i) in temp_df and feed into u 
            
            temp_vec <- as.vector(lof(u,2)) #should make length 3
            
            
            temp_Output_df <- rbind(temp_Output_df,t(data.frame(temp_vec))) # temp_output_df should be 3680x3 from r bind the two dfs
          }
   
        lof_RNAse<- cbind(lof_RNAse,temp_Output_df)
         n <- n + 3
        }

        
        
        


```
*not yet necessary bc lof does not work yet
Removing Values based on if Outlier or not ##results in clean_RNAse_df & clean_Ctrl_df'
```{r}
#modifying the LO factor df  to remove any value above  (arbitrary) 1.5, setting all values < 1.5 = 1 and all values >1.5 = 0
data_clean_func <- function(x,z,treshhold){ # x = data to clean # z = LOF output df RNASe or Ctrl #threshhold can be played around with for signifacance of data
  treshhold_clean_func <- function(y){
    if (y >= treshhold){
      y <- 0
    }else{
      y <- 1
    }
  }
  
  binary_removal_df <- data.frame(apply(z,1,treshhold_clean_func))
  
  x*binary_removal_df
  
}
# i realized we might want to set 0 to NA before doing data cleaning think about it later
clean_RNAse_df <- data_clean_func(norm_RNAse,LOF_RNAse,1.5)
clean_RNAse_df[clean_RNAse_df == 0] <- NA
clean_Ctrl_df <- data_clean_func(norm_Ctrl,LOF_Ctrl,1.5)
clean_Ctrl_df[clean_Ctrl_df == 0] <- NA


```
*not yet necessary bc lof does not work yet 
mean of RNAse and Ctrl reps  ## results in clean_mean_RNAse_df & clean_mean_Ctrl_df
```{r}
# creating mean_clean_RNAse_df 3860x25, normalized and cleaned of outlieres
mean_clean_RNAse_df<- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n<-2
while (n < 75){
    temp_df <- data.frame(clean_RNAse_df[,n],clean_RNAse_df[,n+1],clean_RNAse_df[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    mean_clean_RNAse_df<- cbind(mean_clean_RNAse_df,Output_df)
    n <- n + 3
}
colnames(mean_clean_RNAse_df) = c(paste("RNAse","frac",0:25, sep = "_"))
mean_clean_RNAse_df = mean_clean_RNAse_df[,-1]


# creating mean_clean_Ctrl_df 3860x25, normalized and cleaned of outlieres
mean_clean_Ctrl_df<- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n<-1
while (n < 75){
    temp_df <- data.frame(clean_Ctrl_df[,n],clean_Ctrl_df[,n+1],clean_Ctrl_df[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    mean_clean_Ctrl_df<- cbind(mean_clean_Ctrl_df,Output_df)
    n <- n + 3
}
colnames(mean_clean_Ctrl_df) = c(paste("Ctrl","frac",0:25, sep = "_"))
mean_clean_Ctrl_df = mean_clean_Ctrl_df[,-1]
```

*works
Creating df with median method ##results in 3680 RNAse_median_df & Ctrl_median_df
Wird angenommen, dass der Median eine gute Methode für n=3 stichproben ist, die robust gegenüber OUtlieren ist."https://wis.kuleuven.be/statdatascience/robust/papers/2002/rousseeuwverboven-robustestimationinverysmallsampl.pdf"
```{r}
RNAse_median_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])
    Output_df <-data.frame(apply(temp_df,1,median))
    RNAse_median_df<- cbind(RNAse_median_df,Output_df)
    n <- n + 3
}
colnames(RNAse_median_df) = c(paste("frac",0:25, sep = "_"))
RNAse_median_df = RNAse_median_df[,-1]



Ctrl_median_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_Ctrl[,n],norm_Ctrl[,n+1],norm_Ctrl[,n+2])
    Output_df <-data.frame(apply(temp_df,1,median))
    Ctrl_median_df<- cbind(Ctrl_median_df,Output_df)
    n <- n + 3
}
colnames(Ctrl_median_df) = c(paste("frac",0:25, sep = "_"))
Ctrl_median_df = Ctrl_median_df[,-1]



```


*works
now by arithmetic mean ##results in RNAse_mean_df & Ctrl_mean_df
```{r}
RNAse_mean_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_RNAse[,n],norm_RNAse[,n+1],norm_RNAse[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    RNAse_mean_df<- cbind(RNAse_mean_df,Output_df)
    n <- n + 3
}
colnames(RNAse_mean_df) = c(paste("frac",0:25, sep = "_"))
RNAse_mean_df = RNAse_mean_df[,-1]



Ctrl_mean_df <- data.frame(matrix(nrow = 3680, ncol=1),row.names = row.names(Raw_Data))
n <-1
while (n < 75){
    temp_df <- data.frame(norm_Ctrl[,n],norm_Ctrl[,n+1],norm_Ctrl[,n+2])
    Output_df <-data.frame(apply(temp_df,1,mean))
    Ctrl_mean_df<- cbind(Ctrl_mean_df,Output_df)
    n <- n + 3
}
colnames(Ctrl_mean_df) = c(paste("frac",0:25, sep = "_"))
Ctrl_mean_df = Ctrl_mean_df[,-1]
```

#Wilcox
*(work in progresss)
Wilcox Comparison tests between RNAse and Ctrl ##results in wilcox_pval_df
```{r}
library(rstatix)
library(stats)
'NONE OF THIS WORKS the output of the wilcox function is a list, we need to access the "statistic value" or the "p.value"'

#creating function to use with our cleaned data for applying wilcox
wilcox_apply_func <-function(x,y){
    output_vec <- vector()
    i <-1
    while(i <= 3680 ){
    #taking rows and making them into vectors usable by the wicoxsonfunc
    u <-unname(as.vector(as.matrix(x[i,]))) 'needs to be an unnamed vector'
    v <-unname(as.vector(as.matrix(y[i,])))
    
    #applyig wilcox to each set of paired control and RNASe vectors
    wilcox_val <- wilcox.test(u,v, exact = FALSE) 'works till here'
                            
    #generating an output vector to store the outputs 
    output_vec <- append(output_vec, wilcox_val$p.value, after = length(output_vec))   #the $p.value should access the list
    i <-i+1
    }
    #saving the output vector as a dataframe with  dim 3680x1 from output_vec
    #wilcox_scores_df <-data.frame(output_vec, row.names = row.names(x))
    #colnames(wilcox_scores_df) <- c("Wilcox_score")
    
}

median_wilcox <- wilcox_apply_func(RNAse_median_df,Ctrl_median_df)

mean_wilcox <- wilcox_apply_func(RNAse_mean_df,Ctrl_mean_df)




'fiddeling with the code'

    output_vec <- vector()
    i <-1
    while(i <= 3680 ){
    #taking rows and making them into vectors usable by the wicoxsonfunc
    u <-unname(as.vector(as.matrix(RNAse_median_df[1,])))
    v <-unname(as.vector(as.matrix(Ctrl_median_df[1,])))
    
    #applyig wilcox to each set of paired control and RNASe vectors
    wilcox_val <- wilcox.test(u,v,exact = FALSE)
                            # alternative = "two.sided",
                            # mu = 0,
                            # paired = TRUE,
                            # exact = FALSE,
                            # correct = FALSE,
                            # conf.int = FALSE,
                            # conf.level = 0.95)
    #generating an output vector to store the outputs 
    append(output_vec, wilcox_val$p.value, after = length(output_vec))   #the $p.value should access the list
    i <-i+1
    }
    #saving the output vector as a dataframe with  dim 3680x1 from output_vec
    wilcox_scores_df <-data.frame(output_vec, row.names = row.names(x))
    colnames(wilcox_scores_df) <- c("Wilcox_score")
    
}


```


*(work in progress)
focusing stat test on changes in fractions 19-25
```{r}


```







# Maxima detection


the global maximum is easely accessible with the max(), the min with min() function
we can acces the location with the which() function, and  we can order the data by size 1,2,3 etc 
local maxima can be defined as =! global maximum and occuring after a decreasing trend on either side of the global maximum
we can generte a test vecotor:
exp_maxima_vec <-c(1,2,3,2,1,6,5,4,2,2,3,4,3,2,5,3,2,1,3,1,4,3,2,2,1)
we expect the maxima to be at positions 3,6,12,15,19,21

the input should be a vector containing the 25 fractions of normalized protein data

*works generating maxima detection testing vector exp_maxima_vec
```{r}
#test vector to look at a complex maxima detection
exp_maxima_vec<-c(1,2,3,2,1,6,5,4,2,2,3,4,3,2,5,3,2,1,3,1,4,3,2,2,1)
barplot(exp_maxima_vec)
```


*works This chunk contains maxima_loc_func a length 25 logicl vec, containing all maxima as True, and a 
Output: maxima_loc_func (x)
testing outputs:    
---exp_maxima_logic_max
---Maxima_location_vector
---exp_maxima_vec

```{r}
'THIS SHIT FINALLY WORKS'
maxima_loc_func <-function(x){
  
  logic_return <-logical(length = 25) #logic vector 25x FALSE
  i <- 1
  while (i <= 25){
# for the first element
    if (i == 1){
      if (x[i] > x[i+1]){
        logic_return[i] <- TRUE
      }
#for the elemets 2-24
    }else if ( i < length(x)){
        if (x[i] > x[i+1] & x[i] > x[i-1]){
          logic_return[i] <- TRUE
        }
#for the last element
    }else if ( i == 25){
      if (x[i] > x[i-1]){
        logic_return[i] <- TRUE
      } 
    }
    i  <- i+1
  }
  return(logic_return)
}

exp_maxima_logic_max <- maxima_loc_func(exp_maxima_vec)
Maxima_location_vector <- Which(exp_maxima_logic_max)
exp_maxima_vec[Maxima_location_vector]

```

an alternative to above function not tested yet
```{r}


maxima_loc_func <-function(x){
  
  logic_return <-logical(length = 25) #logic vector 25x FALSE
  
  for (i in x ){

# for the first elemet
    if (match(i,x) == 1){
      if (x[i] > x[match(i,x)+1]){
        logic_return[i] <- TRUE
      }
#for the elemets 2-24
    }else if ( match(i,x) < length(x)){
        if (i > x[match(i,x)+1] & i > x[match(i,x)-1]){
          logic_return[i] <- TRUE
        }
#for the lase element
    }else{
      if (i > x[match(i,x)-1]){
        logic_return[i] <- TRUE
      } 
    }
  }
  return(logic_return)
}



exp_maxima_logic_max <- maxima_loc_func(exp_maxima_vec)
 exp_maxima_logic_max
 
 
 
```



Idea for the "binning" of the maxima as in location only maxima which are "greater" local maxima
eg 12143....    would be 4 not 2 
so we split up the vector into smaller chunks vector[i:i+j] then check if each value is the maximum in that range then move along shifting by 1 so starting at the second entry in the vector and so on if the reading frame pases over the value and leaves it being true then the values is defined as a local maximum per bin size

```{r}
'in words:
define a "reading" frame that checks if each value in the frame is the maximum or not
so we want "m" elements to be selected at position "n"then we want to check if each value is the maximum in the m elements,
when the reading frame moves to start at "n+1" we want the 

idea: what if the function always acceses the same logical vector but always accesses different positions to change the values of the previous run, could even be the same logical vector generated by maxima_loc_func then wed have one output only, if (m == 1|2) then no binsize is applied, if (m >= 3) binfunction  '


# m = binsize , n = element number
# x = a numeric vector, m = binsize, less than 3 not useful
max_bin_func <-function(x,m){
logic_return2 <-logical(length = 25)
n <-1
while (n <= 25){
  logic_return2[which.max(x[n:n+m])] <- TRUE
 n <- n+1
}
return(logic_return2)
}

max_bin_func(exp_maxima_vec,5)
'need function that assings true in a logical( length = m ) to the value which is the maximum'




'OTHER random idea, what if we check the surrounding values of each maximum to see of its the global maximum in that area, would probs be more efficient
 so if n is a maximum, we check [n-m:n+m] and see if its = to the global max of the area, issues with two identical maxima....
'
# just noting that exp_maxima_vec[1:3]<-c(11:13) works for the replacing of values so value replacement works easily
```

